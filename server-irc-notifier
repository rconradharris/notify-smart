#!/usr/bin/env python
"""
Send a email/SMS notification if the user is idle on their laptop.

Idle is determined by the user running a program on their laptop
(client-irc-notifier) which constantly sends idle-time back to the server where
this script runs.

This script doesn't exit and is intended to be run inside a GNU screen
session window

Configure using .irssi/server-irc-notifier.cfg
"""

import ConfigParser
import os
import random
import subprocess
import sys
import time


CONFIG_FILE = '.irssi/server-irc-notifier.cfg'
IDLE_TIME_PATH = '.irssi/idle-time'
FORCE_IDLE_PATH = '.irssi/force-idle'
FNOTIFY_LOG = '.irssi/fnotify'

DEFAULT_DEBUGLEVEL = 0
DEFAULT_POLL_INTERVAL = 1.0
DEFAULT_IDLE_THRESHOLD = 60.0
DEFAULT_TITLE = '[IRC]'

CONST_IDLE = 9999.0  # For our purposes, this will do as a maxint
CONST_NOT_IDLE = -1.0


def safe_read_float(filename):
    """Read a file and interpret value as a float.

    Returns `None` if file is not present, or value is invalid.
    """
    if os.path.exists(filename):
        with open(filename) as f:
            try:
                return float(f.read().strip())
            except ValueError:
                pass
    return None


def get_idle_time():
    """Return a time in seconds since a user was last seen or CONST_IDLE or
    CONST_NOT_IDLE if we're forcing a particular value.
    """
    # Check for force values first...
    force_val = safe_read_float(FORCE_IDLE_PATH)
    if force_val is not None:
        if force_val == 1.0:
            return CONST_IDLE
        elif force_val == 2.0:
            return CONST_NOT_IDLE

    idle_time = safe_read_float(IDLE_TIME_PATH)

    # Ensure idle-time file is present...
    if idle_time is None:
        return CONST_IDLE

    # Check when idle-time file was last-updated
    last_updated = time.time() - os.path.getmtime(IDLE_TIME_PATH)

    # If file is 'stale', then use last_updated, otherwise return the time in
    # the idle-time file
    return last_updated if last_updated > idle_time else idle_time


class NotifierError(Exception):
    pass


class Notifier(object):
    def __init__(self, cfg):
        self.cfg = cfg

    def notify(self, msg):
        pass

    def _get_title(self):
        try:
            return self.cfg.get('general', 'title')
        except ConfigParser.NoOptionError:
            return DEFAULT_TITLE

    @staticmethod
    def get(cfg):
        name = cfg.get('general', 'notifier')
        cls = NOTIFIERS[name]
        return cls(cfg)


class EmailNotifier(Notifier):
    @staticmethod
    def _smtp_connect(host, user, password, debuglevel=0):
        import smtplib

        server = smtplib.SMTP(host)
        server.set_debuglevel(debuglevel)
        server.ehlo()
        server.starttls()
        server.login(user, password)
        return server

    @staticmethod
    def _smtp_close(server):
        server.quit()

    @staticmethod
    def _smtp_send(server, from_email, to_email, body=None, subject=None):
        from email.mime.text import MIMEText

        msg = MIMEText(body)
        if subject:
            msg['Subject'] = subject
        msg['From'] = from_email
        msg['To'] = to_email
        server.sendmail(from_email, [to_email], msg.as_string())

    def notify(self, msg):
        try:
            debuglevel = self.cfg.getint('email', 'debuglevel')
        except ConfigParser.NoOptionError:
            debuglevel = DEFAULT_DEBUGLEVEL

        try:
            server = self._smtp_connect(self.cfg.get('email', 'smtp_host'),
                                        self.cfg.get('email', 'smtp_user'),
                                        self.cfg.get('email', 'smtp_password'),
                                        debuglevel=debuglevel)
        except:
            raise NotifierError

        try:
            self._smtp_send(server,
                            self.cfg.get('email', 'from_email'),
                            self.cfg.get('email', 'to_email'),
                            body=msg,
                            subject=self._get_title())
        except:
            raise NotifierError
        finally:
            self._smtp_close(server)


class PushoverNotifier(Notifier):
    API_URL = 'https://api.pushover.net/1/messages.json'

    def notify(self, msg):
        import requests

        data = {
            'token': self.cfg.get('pushover', 'app_token'),
            'user': self.cfg.get('pushover', 'user_api_key'),
            'title': self._get_title(),
            'message': msg
        }

        resp = requests.post(self.API_URL, data=data)
        if not resp.ok:
            raise NotifierError


NOTIFIERS = {
    'email': EmailNotifier,
    'pushover': PushoverNotifier
}


LAST_MTIME = None


def add_reply_link(cfg, msg):
    """
    fnotify.pl produces two different types of msg formats:
    hilite:
        #channel < user1> user2: text
    privmsg:
        user2 text
    """
    try:
        reply_url = cfg.get('general', 'reply_url')
    except ConfigParser.NoOptionError:
        return msg
    if not reply_url.endswith('/'):
        reply_url += '/'
    target = msg.split(' ', 1)[0]
    reply_url += target
    return " ".join([msg, reply_url])


def format_message(cfg, msg):
    return add_reply_link(cfg, msg)


def process(cfg):
    global LAST_MTIME

    if not os.path.exists(FNOTIFY_LOG):
        print "warning: No fnotify file present..."
        return

    idle_time = get_idle_time()

    try:
        threshold  = cfg.getfloat('general', 'idle')
    except ConfigParser.NoOptionError:
        threshold = DEFAULT_IDLE_THRESHOLD

    print "IDLE TIME = {:<10.1f} "\
          "THRESHOLD = {:<10.1f} "\
          "STATUS = {:<10}".format(
                  idle_time,
                  threshold,
                  'IDLE' if idle_time > threshold else 'NOT IDLE')

    mtime = os.path.getmtime(FNOTIFY_LOG)

    # Don't send last message recv'd on startup...
    if LAST_MTIME is None:
        LAST_MTIME = mtime

    if mtime > LAST_MTIME:
        # Update LAST_MTIME to ensure we don't resend the msg
        LAST_MTIME = mtime

        if idle_time > threshold:
            with open(FNOTIFY_LOG) as f:
                msg =  f.read().splitlines()[-1]
                msg = format_message(cfg, msg)
                print "Sending Notification: ", msg
                Notifier.get(cfg).notify(msg)


def usage():
        print "server-irc-notifier <start|test>"
        sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        usage()

    if not os.path.exists(CONFIG_FILE):
        print "error: required config file not found at '{}'".format(CONFIG_FILE)
        sys.exit(1)

    cfg = ConfigParser.ConfigParser()
    cfg.read(CONFIG_FILE)

    if sys.argv[1] == 'start':
        try:
            poll_interval  = cfg.getfloat('general', 'poll_interval')
        except ConfigParser.NoOptionError:
            poll_interval = DEFAULT_POLL_INTERVAL
        while True:
            process(cfg)
            time.sleep(poll_interval)
    elif sys.argv[1] == 'test':
        notifier = Notifier.get(cfg)
        notifier.notify(random.choice(['apple', 'blackberry', 'cherry',
                                       'dewberry', 'elderberry']))
    else:
        usage()
